---

title: SQL


keywords: fastai
sidebar: home_sidebar

summary: "Recipes for SQL"
description: "Recipes for SQL"
nb_path: "nbs/02_data_prep/sql.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02_data_prep/sql.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Basics">Basics<a class="anchor-link" href="#Basics"> </a></h2><ul>
<li>For basics on how to run 90% of queries, see the <a href="https://mode.com/sql-tutorial/introduction-to-sql/">Mode Analytics guide for Basic and Intermediate SQL</a>.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Tips">Tips<a class="anchor-link" href="#Tips"> </a></h2><ul>
<li>Materialize small chunks of tables (e.g. <code>LIMIT 1000</code>) to test queries on.  This prevents you from wasting resources and potentially locking the database.</li>
<li>Write queries in logical pieces.  Think about what the joins represent, what you're selecting, and use CTEs for logical grouping.</li>
<li>Use comments sparingly.  The code should read like prose.<ul>
<li>The risk of using comments is that they don't automatically update when you update the code.  If that happens, the comment may have nothing to do with the code and you may get confused.</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Window-Functions">Window Functions<a class="anchor-link" href="#Window-Functions"> </a></h2><ul>
<li>Commonly used when a query requires a "window" (group) of adjacent rows (e.g. rolling stats, running stats, previous/subsequent events, etc.)</li>
<li>Similar to <code>GROUP BY</code>, but aggregation happens only for adjacent rows instead of the entire window.</li>
<li>Can provide <code>GROUP BY</code> behaviour within the window using <code>PARTITION BY</code></li>
<li>Ordering is not required if the table is guaranteed to be ordered.  <a href="https://sqlsunday.com/2021/02/15/is-a-sort-faster-when-data-already-sorted/">Ordering an ordered table may cause performance issues.</a></li>
<li>If using the same window repeatedly, some dialect allow for alises via <code>WINDOW {name} AS</code>  (example in <a href="#rolling_window_statistics">rolling_window_statistics</a>)</li>
<li>Some examples provided below:</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Rolling-stats">Rolling stats<a class="anchor-link" href="#Rolling-stats"> </a></h3><ul>
<li><p>Example with <a href="https://en.wikipedia.org/wiki/Bollinger_Bands">Bollinger Bands</a> where $N=20, K=2$</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">stats</span> <span class="k">as</span> <span class="p">(</span>
      <span class="k">select</span>
          <span class="n">date_time</span>
          <span class="p">,</span> <span class="n">ticker</span>
          <span class="p">,</span> <span class="k">avg</span><span class="p">(</span><span class="n">price</span><span class="p">)</span>    <span class="n">over</span> <span class="n">sma20_window</span> <span class="k">as</span> <span class="n">SMA20</span>     
          <span class="p">,</span> <span class="n">stddev</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="n">over</span> <span class="n">sma20_window</span> <span class="k">as</span> <span class="n">STD20</span>  
      <span class="k">from</span> <span class="n">stock_prices</span>
      <span class="n">window</span> <span class="n">sma20_window</span> <span class="k">as</span> <span class="p">(</span>
          <span class="n">partition</span> <span class="k">by</span> <span class="n">ticker</span>
          <span class="k">order</span> <span class="k">by</span> <span class="n">date_time</span>
          <span class="k">rows</span> <span class="k">between</span> <span class="mi">19</span> <span class="n">preceding</span> <span class="k">and</span> <span class="k">current</span> <span class="k">row</span>
      <span class="p">)</span>
  <span class="p">)</span>

  <span class="k">select</span>
      <span class="n">date_time</span>
      <span class="p">,</span> <span class="n">ticker</span>
      <span class="p">,</span> <span class="n">SMA20</span>
      <span class="p">,</span> <span class="n">SMA20</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">STD20</span> <span class="k">as</span> <span class="n">BB20_2_UPPER</span>
      <span class="p">,</span> <span class="n">SMA20</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">STD20</span> <span class="k">as</span> <span class="n">BB20_2_LOWER</span>
  <span class="k">from</span> <span class="n">stats</span>
</pre></div>
</li>
<li><p>Alternatively, without <code>WINDOW AS</code>:</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">stats</span> <span class="k">as</span> <span class="p">(</span>
      <span class="k">select</span>
          <span class="n">date_time</span>
          <span class="p">,</span> <span class="n">ticker</span>
          <span class="p">,</span> <span class="k">avg</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="n">over</span> <span class="p">(</span>      
              <span class="n">partition</span> <span class="k">by</span> <span class="n">ticker</span>
              <span class="k">order</span> <span class="k">by</span> <span class="n">date_time</span>
              <span class="k">rows</span> <span class="k">between</span> <span class="mi">19</span> <span class="n">preceding</span> <span class="k">and</span> <span class="k">current</span> <span class="k">row</span><span class="p">)</span> <span class="k">as</span> <span class="n">SMA20</span>
          <span class="p">,</span> <span class="n">stddev</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="n">over</span> <span class="p">(</span>
              <span class="n">partition</span> <span class="k">by</span> <span class="n">ticker</span>
              <span class="k">order</span> <span class="k">by</span> <span class="n">date_time</span>
              <span class="k">rows</span> <span class="k">between</span> <span class="mi">19</span> <span class="n">preceding</span> <span class="k">and</span> <span class="k">current</span> <span class="k">row</span><span class="p">)</span> <span class="k">as</span> <span class="n">STD20_2</span>
      <span class="k">from</span> <span class="n">stock_prices</span>
  <span class="p">)</span>

  <span class="k">select</span>
      <span class="n">date_time</span>
      <span class="p">,</span> <span class="n">ticker</span>
      <span class="p">,</span> <span class="n">SMA20</span>
      <span class="p">,</span> <span class="n">SMA20</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">STD20</span> <span class="k">as</span> <span class="n">BB20_2_UPPER</span>
      <span class="p">,</span> <span class="n">SMA20</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">STD20</span> <span class="k">as</span> <span class="n">BB20_2_LOWER</span>
  <span class="k">from</span> <span class="n">stats</span>
</pre></div>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Running-stats">Running stats<a class="anchor-link" href="#Running-stats"> </a></h3><ul>
<li>Specifying rows between <code>unbounded</code> gets all preceding rows<div class="highlight"><pre><span></span><span class="k">select</span>
      <span class="n">date_time</span>
      <span class="p">,</span> <span class="n">store</span>
      <span class="p">,</span> <span class="k">sum</span><span class="p">(</span><span class="n">sales</span><span class="p">)</span> <span class="n">over</span> <span class="n">stores_alltime</span> <span class="k">as</span> <span class="n">cumulative_sales</span>   
  <span class="k">from</span> <span class="n">store_sales</span>
  <span class="n">window</span> <span class="n">stores_alltime</span> <span class="k">as</span> <span class="p">(</span>
      <span class="n">partition</span> <span class="k">by</span> <span class="n">store</span>
      <span class="k">order</span> <span class="k">by</span> <span class="n">date_time</span>
      <span class="k">rows</span> <span class="k">between</span> <span class="n">unbounded</span> <span class="n">preceding</span> <span class="k">and</span> <span class="k">current</span> <span class="k">row</span>
  <span class="p">)</span>
</pre></div>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Previous-or-subsequent-events">Previous or subsequent events<a class="anchor-link" href="#Previous-or-subsequent-events"> </a></h3><ul>
<li>Use <code>LAG(col, n)</code> or <code>LEAD(col, n)</code> to move backwards or forwards by <code>n</code> rows</li>
<li><p>Previous events:</p>
<div class="highlight"><pre><span></span><span class="k">select</span>
      <span class="n">date_time</span>
      <span class="p">,</span> <span class="n">lag</span><span class="p">(</span><span class="n">sales</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- sales from the previous row</span>
  <span class="k">from</span> <span class="n">store_sales</span>
</pre></div>
</li>
<li><p>Subsequent events:</p>
<div class="highlight"><pre><span></span><span class="k">select</span>
      <span class="n">date_time</span>
      <span class="p">,</span> <span class="n">lead</span><span class="p">(</span><span class="n">sales</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- sales from the subsequent row</span>
  <span class="k">from</span> <span class="n">store_sales</span>
</pre></div>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Ranking">Ranking<a class="anchor-link" href="#Ranking"> </a></h3><ul>
<li>Use <code>RANK()</code> and <code>DENSE_RANK()</code> for ranking.  If two values are the same, they will have the same rank.<ul>
<li>For <code>RANK()</code>: Ties are the same, but next rankings are skipped (e.g. if 3 items tied at rank 2, then next rank is 5)</li>
<li>For <code>DENSE_RANK()</code>: Ties are the same, and next rankings are not skipped (e.g. if 3 items tied at rank 2, then next rank is 3)<div class="highlight"><pre><span></span><span class="k">select</span>
    <span class="n">quarter</span>
    <span class="p">,</span> <span class="n">salesperson</span>
    <span class="p">,</span> <span class="n">rank</span><span class="p">()</span>       <span class="n">over</span> <span class="n">quarterly</span> <span class="k">as</span> <span class="n">rank</span>
    <span class="p">,</span> <span class="n">dense_rank</span><span class="p">()</span> <span class="n">over</span> <span class="n">quarterly</span> <span class="k">as</span> <span class="n">dense_rank</span>
<span class="k">from</span> <span class="n">sales</span>
<span class="n">window</span> <span class="n">quarterly</span> <span class="k">as</span> <span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="n">quarter</span> <span class="k">order</span> <span class="k">by</span> <span class="n">sum_sales</span><span class="p">)</span>
</pre></div>
</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Percentiles">Percentiles<a class="anchor-link" href="#Percentiles"> </a></h3><ul>
<li>Use <code>NTILE(k)</code> to break data into <code>k</code> partitions.  The return value is the partition that row belongs to.<div class="highlight"><pre><span></span><span class="k">select</span>
      <span class="n">quarter</span>
      <span class="p">,</span> <span class="n">salesperson</span>
      <span class="p">,</span> <span class="n">ntile</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="n">over</span> <span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="n">quarter</span> <span class="k">order</span> <span class="k">by</span> <span class="n">sum_sales</span><span class="p">)</span> <span class="k">as</span> <span class="n">percentile</span>
  <span class="k">from</span> <span class="n">sales</span>
</pre></div>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Subqueries-and-CTEs">Subqueries and CTEs<a class="anchor-link" href="#Subqueries-and-CTEs"> </a></h2><ul>
<li>Sometimes it's easier to write (and later read) your query as multiple stages</li>
<li><p>Performance in modern SQL dialects should be the same for CTEs vs subqueries</p>
<ul>
<li>For older dialects, you may run into an <a href="https://www.2ndquadrant.com/en/blog/postgresql-ctes-are-optimization-fences/">optimization fence</a></li>
</ul>
</li>
<li><p>Without CTE:</p>
<div class="highlight"><pre><span></span><span class="k">select</span> <span class="o">*</span>
  <span class="k">from</span> <span class="p">(</span>
      <span class="k">select</span> <span class="o">*</span>
      <span class="k">from</span> <span class="n">tbl</span>
  <span class="p">)</span>
  <span class="k">group</span> <span class="k">by</span> <span class="n">def</span>
</pre></div>
</li>
<li><p>With CTE:</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">xyz</span> <span class="k">as</span> <span class="p">(</span>
      <span class="k">select</span> <span class="o">*</span>
      <span class="k">from</span> <span class="n">tbl</span>
  <span class="p">)</span>

  <span class="k">select</span> <span class="o">*</span>
  <span class="k">from</span> <span class="n">xyz</span>
  <span class="k">group</span> <span class="k">by</span> <span class="n">def</span>
</pre></div>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Query-Optimization">Query Optimization<a class="anchor-link" href="#Query-Optimization"> </a></h2><h3 id="Minimizing-Join-Cost">Minimizing Join Cost<a class="anchor-link" href="#Minimizing-Join-Cost"> </a></h3><ul>
<li><p>Filter all component tables as much as possible before attempting a join.  You can use CTEs for readability and organization.</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">table1_filtered</span> <span class="k">as</span> <span class="p">(</span>
      <span class="k">select</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="k">c</span>
      <span class="k">from</span> <span class="n">table1</span>
      <span class="k">where</span> <span class="n">condition1</span>
      <span class="k">limit</span> <span class="mi">10000</span>
  <span class="p">)</span>

  <span class="p">,</span> <span class="n">table2_filtered</span> <span class="k">as</span> <span class="p">(</span>
      <span class="k">select</span> <span class="k">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span>
      <span class="k">from</span> <span class="n">table2</span>
      <span class="k">where</span> <span class="n">condition2</span> <span class="k">and</span> <span class="n">condition3</span>
  <span class="p">)</span>

  <span class="k">select</span> <span class="n">t1</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="k">c</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">d</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">e</span>
  <span class="k">from</span> <span class="n">table1_filtered</span> <span class="n">t1</span>
  <span class="k">left</span> <span class="k">join</span> <span class="n">table2_filtered</span> <span class="n">t2</span> <span class="k">on</span> <span class="n">t1</span><span class="p">.</span><span class="k">c</span> <span class="o">==</span> <span class="n">t2</span><span class="p">.</span><span class="k">c</span>
</pre></div>
</li>
</ul>
<h3 id="EXPLAIN-ANALYZE">EXPLAIN ANALYZE<a class="anchor-link" href="#EXPLAIN-ANALYZE"> </a></h3><ul>
<li>Returns the query plan and estimated cost for each step</li>
<li>If you think you can find a better plan than the optimizer, you can force a specific plan using the Query Store (or <code>pg_stat_statements</code>)</li>
</ul>
<h3 id="INDEX">INDEX<a class="anchor-link" href="#INDEX"> </a></h3><ul>
<li>By default, a clustered index is created on the primary key of a table.</li>
<li>A custom clustered index can speed up queries, but slow down inserts.  For analytics DBs in general, faster queries are better.</li>
</ul>
<h3 id="MATERIALIZE-(VIEW)">MATERIALIZE (VIEW)<a class="anchor-link" href="#MATERIALIZE-(VIEW)"> </a></h3><ul>
<li>View: From a set of source tables, create an imaginary table that can be computed when requried</li>
<li>Materialized View: Store the intermediate steps in memory to make viewing the table faster (useful for analytical tables)</li>
<li></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="PIVOTs">PIVOTs<a class="anchor-link" href="#PIVOTs"> </a></h2><ul>
<li>Personally, I find pivots in SQL to be very ugly.  Try pivoting in another tool if possible (e.g. Spark, Pandas, etc.)</li>
<li>Reference here: <a href="https://mode.com/sql-tutorial/sql-pivot-table/">https://mode.com/sql-tutorial/sql-pivot-table/</a></li>
</ul>

</div>
</div>
</div>
</div>
 

