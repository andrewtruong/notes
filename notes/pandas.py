# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_data_prep/pandas.ipynb (unless otherwise specified).

__all__ = ['categorize', 'deduplicate', 'normalize_col_names', 'log_dtypes', 'log_transform', 'read_files', 'localize',
           'strip_whitespace', 'fold', 'normalize']

# Cell
import logging
from functools import wraps
from pathlib import Path
from timeit import default_timer as timer

import pandas as pd
from tqdm.auto import tqdm

# Cell
def categorize(df, categories):
    for col, kwargs in categories.items():
        df[col] = pd.Categorical(df[col], **kwargs)
    return df

# Cell
def deduplicate(df, axis='rows', subset=None, keep='first'):
    if axis in ['rows', 0]:
        return df[~df.duplicated(subset=subset, keep=keep)]
    elif axis in ['columns', 1]:
        return df.T[~df.T.duplicated(subset=subset, keep=keep)].T
    else:
        raise InvalidOption('Please specify valid axis (`rows` or `columns`)')

# Cell
from fastcore.all import typedispatch
import pandas as pd
from nbdev.showdoc import show_doc

@typedispatch
def normalize_str(s:str) -> str:
    return s.replace(' ', '_').lower()

@typedispatch
def normalize_str(s:pd.Series) -> pd.Series:
    return s.str.replace(' ', '_').str.lower()

normalize_str.__name__ = 'normalize_str'
normalize_str.__doc__ = '''
Convert spaces to underscore, and lowercase all chars.
For `s:str`: use built-in python methods
For `s:pd.Series`: use pandas methods
'''
show_doc(normalize_str)

# Cell
def normalize_col_names(df):
    '''
    Replace whitespace with underscore, and
    '''
    df.columns = df.columns.str.replace(' ', '_').str.lower()
    return df

# Cell
def log_dtypes(func):
    '''
    Decorate your function to log `df.dtypes` after it is complete.

    Example:
    ```python
    @log_dtypes
    def func(df): pass
    ```
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        logging.info(f"Dtypes: \n{result.dtypes}")
        return result

    return wrapper


# Cell
def log_transform(func):
    '''
    Decorate your function to get execution time and log `df.shape` after it is complete.

    Example:
    ```python
    @log_transform
    def func(df): pass
    ```
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = timer()
        result = func(*args, **kwargs)

        end_time = timer()
        elapsed_time = end_time - start_time

        shape = [f"{dim:>4,}" for dim in result.shape]
        shape = ";".join(shape)

        if elapsed_time < 60:
            units = "sec"
        elif elapsed_time < (3600):
            units = "min"
            elapsed_time /= 60
        else:
            units = "hours"
            elapsed_time /= 3600

        # print(f"Elapsed Time: {elapsed_time:,.3f}s")
        logging.info(
            " " * 3
            + f"Executed: {func.__name__}".ljust(40)
            + f"Elapsed: {elapsed_time:,.1f}{units}".ljust(25)
            + f"Shape: {shape}"
        )
        return result

    return wrapper

# Cell
def read_files(path, pattern, filetype='csv'):
    read = {
        'csv': pd.read_csv,
        'feather': pd.read_feather,
        'parquet': pd.read_parquet
    }

    files = list(Path(path).glob(pattern))
    dfs = (read(f) for f in tqdm(files))
    return pd.concat(dfs)

# Cell
def localize():
    pass

# Cell
def strip_whitespace(df):
    for col in df.columns[df.dtypes == "string"]:
        df[col] = df[col].str.rstrip()
    return df

# Cell
def fold(x,y):
    return x&y

# Cell

def normalize(df, by, how='first'):
    if how not in ['first', 'last']:
        raise InvalidOption('Parameter `how` be either `first` or `last`')
    return df / df.groupby(by).transform(how)