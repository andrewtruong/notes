# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/data_science/data_collection.ipynb (unless otherwise specified).

__all__ = ['ImgDownloader']

# Cell
import httpx
import re
from pathlib import Path
from tqdm.auto import tqdm
from fastcore.all import typedispatch
from .asyncio import async_map

# Cell
class ImgDownloader:
    def __init__(self, n_imgs=5, valid_exts=["jpg", "jpeg", "png"], save_path='./images'):
        self.n_imgs = n_imgs
        self.batch_size = min(n_imgs, 100)
        self.valid_exts = valid_exts
        self.save_path = save_path
        self.download_counter = {}
        self.page_counter = {}

    def _setup_counters(self, query):
        if query not in self.download_counter:
            self.download_counter[query] = 1
            self.page_counter[query] = 0

    async def get_links(self, query, client):
        links = []
        try:
            r = await client.get(f"https://www.bing.com/images/async?q={query}&first={self.page_counter}&count={self.batch_size}")
        except Exception as e:
            pass
        else:
            html = r.read().decode("utf8")
            links = re.findall("murl&quot;:&quot;(.*?)&quot;", html)
        finally:
            return links

    def get_ext(self, r):
        ext = r.headers.get("content-type", '/').split("/")[-1]
        if self.valid_exts and ext not in self.valid_exts:
            raise InvalidExt(f"Extension {ext} not in {self.valid_exts}")
        return ext

    async def get_img(self, link, savename, client):
        'Download an image from `link` and save as `savename` via `client` (async)'
        try:
            r = await client.get(link)
        except Exception as e:
            pass
        else:
            ext = self.get_ext(r)
            img = r.read()
            with open(f"{savename}.{ext}", "wb") as f:
                f.write(img)

    async def _get_imgs(self, query):
        self._setup_counters(query)
        folder = Path(f"{self.save_path}/{query}")
        folder.mkdir(parents=True, exist_ok=True)

        with tqdm(total=self.n_imgs, leave=False, desc=query) as pbar:
            async with httpx.AsyncClient() as client:
                while self.download_counter[query] <= self.n_imgs:
                    for link in await self.get_links(query, client=client):
                        if self.download_counter[query] > self.n_imgs:
                            break
                        try:
                            await self.get_img(
                                link,
                                savename=f"{folder}/{query}{self.download_counter[query]}",
                                client=client,
                            )
                        except InvalidExt as e:
                            pass
                        else:
                            self.download_counter[query] += 1
                            pbar.update(1)

    # this method added to simplify API for end user (synchronous function for both `str` and `list` types)
    @typedispatch
    def get_imgs(self, query:str):
        asyncio.run(self._get_imgs(query))

    @typedispatch
    def get_imgs(self, query:list, chunksize=False):
        if chunksize:
            _chunks = list(chunks(query, chunksize))
            for i, chunk in enumerate(tqdm(_chunks, desc='Downloading Images'), 1):
                asyncio.run(async_map(self._get_imgs, chunk, tqdm_kwargs={'desc': f'Chunk {i}/{len(_chunks)}'}), debug=True)
        else:
            asyncio.run(async_map(self._get_imgs, query, tqdm_kwargs={'desc': 'Downloading Images'}), debug=True)

    get_imgs.__name__ = 'get_imgs'
    get_imgs.__qualname__ = 'ImgDownloader.get_imgs'
    get_imgs.__doc__ = '''
Download all images.
- For `query:str`, download one image.
- For `query:list` download multiple images in chunks
'''